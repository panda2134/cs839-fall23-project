Require Import ZArith.
Require Import Coq.Lists.List.
Import ListNotations.
Require Coq.Program.Wf.
Require Import Recdef.

Inductive Expr: Type :=
    Num: Z -> Expr
  | Plus: Expr -> Expr -> Expr
  | Minus: Expr -> Expr -> Expr
  | VarX: Expr
  | VarY: Expr
  | IteZero: Expr -> Expr -> Expr -> Expr
  .

Inductive Stmt: Type :=
    LetX: Expr -> Stmt -> Stmt
  | LetY: Expr -> Stmt -> Stmt
  | Write: Expr -> Stmt
  | Seq: Stmt -> Stmt -> Stmt
  .


(* cannot handle func call: recursiveness? *)
(* I even don't know how to handle it when recursing is not allowed! *)

Fixpoint evalExpr (e: Expr) (varX: Z) (varY: Z): Z :=
  match e with
  | Num n => n
  | Plus e1 e2 => (evalExpr e1 varX varY) + (evalExpr e2 varX varY)
  | Minus e1 e2 => (evalExpr e1 varX varY) - (evalExpr e2 varX varY)
  | VarX => varX
  | VarY => varY
  | IteZero ec el er =>
       let cond := (evalExpr ec varX varY) in
       let l := (evalExpr el varX varY) in
       let r := (evalExpr er varX varY) in
       match cond with
       | Z0 => l
       | _ => r
       end
  end.

Fixpoint evalStmt (s: Stmt) (varX: Z) (varY: Z) : list Z :=
  match s with
  | LetX e1 e2 => let varX' := (evalExpr e1 varX varY) in 
                    (evalStmt e2 varX' varY)
  | LetY e1 e2 => let varY' := (evalExpr e1 varX varY) in
                    (evalStmt e2 varX varY')
  | Write e => [(evalExpr e varX varY)]
  | Seq p q => (evalStmt p varX varY) ++ (evalStmt q varX varY)
  end.

Example E1: (Z.to_nat (evalExpr (Plus (Num 3) VarX) 2 3)) = 5.
Proof.
  auto.
Qed.

Example E2: (Z.to_nat (evalExpr (IteZero (Minus (Num 1) (Num 1)) VarX VarY) 3 5)) = 3.
Proof. unfold evalExpr. auto.
Qed.

Example E3: ((evalStmt (Seq (LetX (Num 1) (LetY (Num 2) (Write VarX))) (Write VarY)) 3 4) = [1%Z; 4%Z]).
Proof. unfold evalStmt. simpl. reflexivity.
Qed.

Inductive Instr: Type := 
    IPlus: Instr
  | IMinus: Instr
  | ICondPick: Instr (* Remove all 3 elements. If StackTop is Zero then Pick StackTop-1 else Pick StackTop-2 *)
  | IWrite: Instr    (* Write Stack Top to Output*)
  | ILoadX: Instr    (* Pop *)
  | ILoadY: Instr
  | IPop: Instr
  | IStoreX: Instr   (* Push *)
  | IStoreY: Instr
  | IStoreImm: Z -> Instr
  | IDup: Instr
  | ISwap: Instr.

(* return: stack & write events *)
Fixpoint evalInstr (prog: (list Instr)) (stack: list Z) (regX: Z) (regY: Z): option (list Z * list Z) :=
  match (prog, stack) with
  | (nil, result) => Some(result, [])
  | (IPlus :: prog', n1 :: n2 :: rest) => (evalInstr prog' ((n2 + n1)%Z :: rest) regX regY)
  | (IMinus :: prog', n1 :: n2 :: rest) => (evalInstr prog' ((n2 - n1)%Z :: rest) regX regY)
  | (IWrite :: prog', n :: rest) => match (evalInstr prog' stack regX regY) with
                                    | Some(stack', evt') => Some(stack', n :: evt')
                                    | None => None
                                    end
  | (ICondPick :: prog', cond :: l :: r :: rest) =>
    match cond with
    | Z0 => (evalInstr prog' (l :: rest) regX regY)
    | _ => (evalInstr prog' (r :: rest) regX regY)
    end
  | (ILoadX :: prog', n :: rest) => (evalInstr prog' rest n regY)
  | (ILoadY :: prog', n :: rest) => (evalInstr prog' rest regX n)
  | (IStoreX :: prog', _) => (evalInstr prog' (regX :: stack) regX regY)
  | (IStoreY :: prog', _) => (evalInstr prog' (regY :: stack) regX regY)
  | ((IStoreImm imm) :: prog', _) => (evalInstr prog' (imm :: stack) regX regY)
  | (IPop :: prog', n :: rest) => (evalInstr prog' rest regX regY)
  | (IDup :: prog', n :: rest) => (evalInstr prog' (n :: n :: rest) regX regY)
  | (ISwap :: prog', n1 :: n2 :: rest) => (evalInstr prog' (n2 :: n1 :: rest) regX regY)
  | (_, _) => None
  end.

Example InstrE1: (evalInstr (IDup :: IPlus :: nil) (1%Z :: nil) 0 0) = Some([2%Z], []).
Proof.
  unfold evalInstr.
  auto.
Qed.

Example InstrE2: (evalInstr (IStoreX :: IWrite :: IPop :: nil) [] 3%Z 4%Z) = Some([], [3%Z]).
Proof.
  auto.
Qed.

Fixpoint compileExpr (e: Expr): list Instr :=
  match e with
  | VarX => [IStoreX]
  | VarY => [IStoreY]
  | Num n => [(IStoreImm n)]
  | Plus e1 e2 => 
    let e1Prog := (compileExpr e1) in
    let e2Prog := (compileExpr e2) in
    e1Prog ++ e2Prog ++ [IPlus]
  | Minus e1 e2 => 
    let e1Prog := (compileExpr e1) in
    let e2Prog := (compileExpr e2) in
    e1Prog ++ e2Prog ++ [IMinus]
  | IteZero ec el er =>
    let elProg := (compileExpr el) in
    let erProg := (compileExpr er) in
    let ecProg := (compileExpr ec) in
    erProg ++ elProg ++ ecProg ++ [ICondPick]
  end.

Fixpoint compileStmt (s: Stmt): list Instr :=
  match s with
  | LetX e1 e2 =>
    let e1Prog := (compileExpr e1) in
    let e2Prog := (compileStmt e2) in
    e1Prog ++ [IStoreX ; ISwap ; ILoadX] ++ e2Prog ++ [ILoadX]
  | LetY e1 e2 =>
    let e1Prog := (compileExpr e1) in
    let e2Prog := (compileStmt e2) in
    e1Prog ++ [IStoreY ; ISwap ; ILoadY] ++ e2Prog ++ [ILoadY]
  | Write e => (compileExpr e) ++ [IWrite; IPop]
  | Seq e1 e2 =>
    let e1Prog := (compileStmt e1) in
    let e2Prog := (compileStmt e2) in
    e1Prog ++ e2Prog
  end.

Compute compileStmt (LetX (Num 1) (Write VarX)).

Example CE1: evalInstr (compileStmt (LetX (Num 1) (LetX (Num 2) (Write VarX)))) [] 0 0 = Some([], [2%Z]).
Proof. simpl. reflexivity.
Qed.

Function stackTop (xs: option (list Z)): option Z :=
  match xs with
  | None => None
  | Some(nil) => None
  | Some(x :: rest) => Some(x)
  end.

Lemma step_correct_expr: forall e: Expr, forall x0 y0: Z, forall progs: list Instr, forall st: list Z,
  (evalInstr ((compileExpr e) ++ progs) st x0 y0) = (evalInstr progs ((evalExpr e x0 y0) :: st) x0 y0).
Proof.
  induction e.
  - (*Num*) auto.
  - (*Plus*) simpl.
    intros x0 y0 progs st. repeat rewrite <- app_assoc.
    rewrite IHe1. rewrite IHe2. simpl. reflexivity.
  - (*Minus*) simpl.
    intros x0 y0 progs st. repeat rewrite <- app_assoc.
    rewrite IHe1. rewrite IHe2. simpl. reflexivity.
  - (*VarX*) auto.
  - (*VarY*) auto.
  - (*IteZero*) intros x0 y0 progs st.
    simpl (compileExpr (IteZero e1 e2 e3) ++ progs). repeat rewrite <- app_assoc. rewrite IHe3. rewrite IHe2. rewrite IHe1.
    simpl (evalInstr ([ICondPick] ++ progs) (evalExpr e1 x0 y0 :: evalExpr e2 x0 y0 :: evalExpr e3 x0 y0 :: st) x0 y0).
    destruct (evalExpr e1 x0 y0) eqn:condLeft.
    all: try simpl (evalInstr progs (evalExpr (IteZero e1 e2 e3) x0 y0 :: st) x0 y0).
    * rewrite -> condLeft. try rewrite Z.mul_0_l. simpl. destruct (evalExpr e2 x0 y0). all:repeat auto.
    * rewrite -> condLeft. try rewrite Z.mul_0_l. simpl. destruct (evalExpr e3 x0 y0). all:reflexivity.
    * simpl. destruct (evalExpr e1 x0 y0).
      + discriminate. + reflexivity. + reflexivity.
Qed.

Lemma step_correct_stmt: forall s: Stmt, forall x0 y0: Z, forall progs: list Instr, forall st: list Z,
  let e1 := (evalInstr ((compileStmt s) ++ progs) st x0 y0) in
  let evt0 := (evalStmt s x0 y0) in
  let e2 := (evalInstr progs st x0 y0) in
  let l := match e1 with
           | None => None
           | Some(_, evt) => Some(evt)
           end in
  let r := match e2 with
           | None => None
           | Some(_, evt) => Some(evt0 ++ evt)
           end in
  l = r.
Proof.
  induction s.
  - (*LetX*) simpl.
    intros x0 y0 progs st.
    repeat rewrite <- app_assoc.
    simpl in IHs. rewrite -> step_correct_expr. rewrite IHs.

Theorem compiler_correct: forall e: Expr, forall x0 y0: Z,
  Some(evalExpr e x0 y0) = stackTop (evalInstr (compile e) [] x0 y0).
Proof.
  assert (forall e: Expr, forall x0 y0: Z,
      evalInstr (compile e ++ []) [] x0 y0 = evalInstr (compile e) [] x0 y0).
  - intros. rewrite app_nil_r. reflexivity.
  - intros. rewrite <- H. rewrite step_correct. reflexivity.
Qed.

(* TODO: allow infinite registers by changing state from (x, y) into a dict *)

Inductive ExprContext: Type :=
    CNum: Z -> ExprContext
  | CHole: ExprContext
  | CVarX: ExprContext
  | CVarY: ExprContext
  | CPlusL: ExprContext -> Expr -> ExprContext
  | CPlusR: Expr -> ExprContext -> ExprContext
  | CMinusL: ExprContext -> Expr -> ExprContext
  | CMinusR: Expr -> ExprContext -> ExprContext
  | CLetXL: ExprContext -> Expr -> ExprContext
  | CLetXR: Expr -> ExprContext -> ExprContext
  | CLetYL: ExprContext -> Expr -> ExprContext
  | CLetYR: Expr -> ExprContext -> ExprContext
  | CIteZero1: ExprContext -> Expr -> Expr -> ExprContext
  | CIteZero2: Expr -> ExprContext -> Expr -> ExprContext
  | CIteZero3: Expr -> Expr -> ExprContext -> ExprContext
  .

Fixpoint link_to_context (e: Expr) (ctx: ExprContext): Expr :=
  match ctx with
  | CNum n => (Num n)
  | CHole => e
  | CVarX => (VarX)
  | CVarY => (VarY)
  | CPlusL e1 e2 => Plus (link_to_context e e1) e2
  | CPlusR e1 e2 => Plus e1 (link_to_context e e2)
  | CMinusL e1 e2 => Minus (link_to_context e e1) e2
  | CMinusR e1 e2 => Minus e1 (link_to_context e e2)
  | CLetXL e1 e2 => LetX (link_to_context e e1) e2
  | CLetXR e1 e2 => LetX e1 (link_to_context e e2)
  | CLetYL e1 e2 => LetY (link_to_context e e1) e2
  | CLetYR e1 e2 => LetY e1 (link_to_context e e2)
  | CIteZero1 e1 e2 e3 => IteZero (link_to_context e e1) e2 e3
  | CIteZero2 e1 e2 e3 => IteZero e1 (link_to_context e e2) e3
  | CIteZero3 e1 e2 e3 => IteZero e1 e2 (link_to_context e e3)
  end.

Example LinkE1: link_to_context (Num 3) (CPlusL (CMinusR VarX CHole) (Num 2)) = (Plus (Minus VarX (Num 3)) (Num 2)).
Proof. simpl. reflexivity.
Qed.

